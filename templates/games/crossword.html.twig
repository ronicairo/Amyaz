{% extends 'base.html.twig' %}

{% block title %}{{ 'navigation.game'|trans }}
{% endblock %}

{% block body %}
<style>

#container {
    display: flex;
    justify-content: space-evenly; /* Espace entre la grille et les indices */
    align-items: flex-start; /* Aligner les éléments en haut */
    padding: 30px; /* Ajouter un espacement au-dessus du conteneur */
    background-color: #a7a7a727;
    border-radius: 20px;
    box-shadow: 0 15px 25px rgba(0, 0, 0, 0.6);
}

#crossword {
    margin-right: 20px; /* Ajouter un espace à droite de la grille */
    margin-top: 80px;
}

#clueContainer {
    display: flex;
    flex-direction: column; /* Aligner les indices en colonne */
    justify-content: flex-start;
    width: 200px; /* Largeur fixe pour les indices */
}

.clueGroup {
    display: flex; /* Disposer les sections côte à côte */
    justify-content: space-evenly; /* Espacer les sections */
}

#controls {
    margin-top: 10px;
    text-align: center; /* Centrer les boutons */
}

#clues {
    margin-top: 20px;
    text-align: center; /* Centrer les indices */
}

.clueGroup li {
    list-style-type: none;
    padding: 0;
}

.btn {
    width: 150px;
}

#checkBtn, #showBtn, #resetBtn {
   background: linear-gradient(to bottom, #aacff1,#abd5df);

    color: black;
    margin: 4px;
}

#checkBtn:hover, #showBtn:hover, #resetBtn:hover {
    color: white;
    margin: 4px;
    background-color: black;
}

.crossword {
    border-collapse: collapse;
    clear: both;
}

.crossword td {
    border: 1px solid black;
    padding: 0;
    margin: 0;
    vertical-align: middle;
    text-align: center;
    width: 25px!important;
    height: 25px!important;
    background: white;
}

.crossword .no-border {
    visibility: hidden;
    border: none;
    background-color: #111;
}

.number {
    position: absolute;
    font-size: 12px;
    color: #adadad;
    background: transparent; /* Pour le contraste avec la case */
    border-radius: 50%; /* Arrondir les bords */
    padding: 2px 5px; /* Espacement autour du numéro */
    z-index: 2; /* Assurez-vous qu'il est au-dessus de la cellule */
    pointer-events: none; /* Ignore les événements de la souris pour le numéro */
}


input {
    border: 0;
    padding: 0;
    background: transparent;
    outline: 0;
    text-align: center;
    text-transform: uppercase;
    width: 100%;
    height: 100%;
    cursor: pointer;
}

.crossword td:hover:not(.no-border) {
    background-color: #e9e9e9;
}

.error {
    background-color: #ab0b00bc!important;
}

#tries {
    margin-bottom: 10px;
}

#direction {
    font-weight: bold;
    font-size: 18px;
    color: white;
}

#dir {
    color: blue;
}
@media (max-width: 768px) {
    #container {
        flex-direction: column; /* Stack items vertically */
        align-items: center; /* Center items horizontally */
        padding: 10px; /* Adjust padding for mobile */
        overflow: hidden; /* Prevent overflow */
    }

    #crossword {
        margin: 0; /* Remove right margin for mobile */
        margin-bottom: 20px; /* Add margin below the crossword */
        width: 100%; /* Make the crossword take full width */
        max-width: 400px; /* Set a maximum width to prevent overflow */
        table-layout: fixed; /* Ensure consistent cell sizes */
    }

    #clueContainer {
        width: 100%; /* Full width for clues */
        text-align: center; /* Center the clues */
    }

    #controls {
        margin-top: 10px;
        text-align: center; /* Center the buttons */
    }

    .crossword {
        width: 100%; /* Allow crossword width to adjust */
        margin: auto; /* Center the crossword */
    }

    .crossword td {
        width: 30px; /* Adjust cell width for mobile */
        height: 30px; /* Adjust cell height for mobile */
        word-wrap: break-word; /* Allow wrapping if needed */
    }

    .number {
        font-size: 10px; /* Smaller font size for numbers on mobile */
    }
}
</style>

<main>
<h3 class="text-center mb-4">{{ 'title.crosswordsearch'|trans }}</h3>
<div id="container">
    <div id="crossword"></div>
    <div id="clueContainer">
        <p id="dir">going <span id="direction">across</span></p>
      <div class="clueGroup">
            <div class="across">
                <p>Across</p>
                <div id="across"></div>
            </div>
            <div class="down">
                <p>Down</p>
                <div id="down"></div>
            </div>
        </div>
        <!-- Contrôles -->
        <div id="controls" class="mt-5">
            <div id="tries">{{ 'button.3triesleft'|trans }}</div>
            <button id="checkBtn" class="btn" onclick="countTries()">{{ 'button.checkanswer'|trans }}</button>
            <button id="showBtn" class="btn" disabled onclick="showAnswers()">{{ 'button.showanswer'|trans }}</button>
            <button id="resetBtn" class="btn" onclick="reset()">{{ 'button.reset'|trans }}</button>
        </div>
    </div>
</div>
</main>

<script>
var dir='across',counter = 3,T = false,R = false,B = false,L = false;
function countTries() {
  counter--;
document.getElementById('tries').innerHTML = "{{ 'button.triesleft'|trans }}" +  " " + counter + "  " + "{{ 'button.tries'|trans }}"; 
if (counter <= 1) { 
     document.getElementById('tries').innerHTML = "{{ 'button.triesleft'|trans }}" +  " " + counter + "  " + "{{ 'button.trie'|trans }}"; 
}
  if (counter <= 0) { 
    document.getElementById('showBtn').disabled = false;
    document.getElementById('showBtn').style.background = '#0065ba';
    document.getElementById('showBtn').style.color = 'white';
    document.getElementById('checkBtn').style.background = 'grey';
    document.getElementById('checkBtn').disabled = true;
    document.getElementById('tries').innerHTML = "{{ 'button.triesleft'|trans }}" +  " " + counter + "  " + "{{ 'button.trie'|trans }}"; 
  }
  checkAnswer();
}

function cellFocus(elm) { 
  elm.setSelectionRange(0, 9999);
  keyup(elm,true);
}

function keyup(elm,focus) {
  elm.value = elm.value.replace(/\s+/g, '');
  var row = elm.attributes['data-row'].value;
  var col = elm.attributes['data-col'].value;
  var table = document.getElementById('crossword1');
  T = false; R = false; B = false; L = false;
  var maxrows = table.rows.length;
  var maxcols = table.rows[0].cells.length;
  if (row-2 >= 0 && row-2 < maxrows && col-1 >= 0 && col-1 < maxcols) { T=table.rows[row-2].cells[col-1].children.length > 0; } //(T) cell above?
  if (row-1 >= 0 && row-1 < maxrows && col >= 0 && col < maxcols) { R=table.rows[row-1].cells[col].children.length > 0; } //(R) cell to right?
  if (row >= 0 && row < maxrows && col-1 >= 0 && col-1 < maxcols) { B=table.rows[row].cells[col-1].children.length > 0; } //(B) cell below?
  if (row-1 >= 0 && row-1 < maxrows && col-2 >= 0 && col-2 < maxcols) { L=table.rows[row-1].cells[col-2].children.length > 0; } //(L) cell to left?

  if (T==false && R==true && B==true && L==true && dir=='down') { document.getElementById('direction').innerHTML='down'; dir='down'; }  //top down 
  if (T==true && R==false && B==true && L==false && dir=='down') { document.getElementById('direction').innerHTML='down'; dir='down'; } //down
  if (T==true && B==false && dir=='down') { return; } //bottom down
    
  if (T==true && R==true && B==true && L==false && dir=='across') { document.getElementById('direction').innerHTML='across'; dir='across'; } //left across
  if (L==true && R==false && dir=='across') { return; } //end across

  if (B==true && L==false && focus==true) { document.getElementById('direction').innerHTML='down'; dir='down'}
  if (R==true && T==false && focus==true) { document.getElementById('direction').innerHTML='across'; dir='across'} 
  
  
  if (focus==true) { return; } //onfocus only
  if (dir=='down') { table.rows[row].cells[col-1].children[0].focus(); }
  if (dir=='across') { table.rows[row-1].cells[col].children[0].focus(); }
}

window.addEventListener("load",function(){
  document.getElementById("crossword").addEventListener("dblclick", direction);
  
function direction() {
  if (L==false && R==false || T==false && B==false) { return; } //not an intersection
  if (dir=='across') {dir='down';} else { dir='across';}
    document.getElementById("direction").innerHTML=dir;
  }
},false);

function reset() {
  location.href = location.href;
}
window.onload = function() {
    // Récupère les mots et indices depuis le backend
    var words = {{ words|json_encode|raw }};
    var clues = {{ clues|json_encode|raw }};

    console.log(words);  // Pour vérifier que les mots sont correctement récupérés
    console.log(clues);  // Pour vérifier que les indices sont correctement récupérés

    // Crée l'objet crossword avec les mots et les indices
    var cw = new Crossword(words, clues);
    var tries = 10; 
    var grid = cw.getSquareGrid(tries);

    // Gère les cas où la grille ne peut pas être créée
    if(grid == null){
      var bad_words = cw.getBadWords();
      var str = [];
      for(var i = 0; i < bad_words.length; i++){
        str.push(bad_words[i].word);
      }
      alert("Une grille n'a pas pu être créée avec ces mots :\n" + str.join("\n") + '. Veuillez les changer.');
      return;
    }

    // Transforme la grille de mots croisés en HTML
    var show_answers = false;
    document.getElementById("crossword").innerHTML = CrosswordUtils.toHtml(grid, show_answers);
    var legend = cw.getLegend(grid);
    addLegendToPage(legend);
};


function addLegendToPage(groups){
  for(var k in groups) {
    var html = [];
    for(var i = 0; i < groups[k].length; i++) {
      html.push("<li><strong>" + groups[k][i]['position'] + ".</strong> " + groups[k][i]['clue'] + "</li>");
    }
    document.getElementById(k).innerHTML = html.join("\n");
  }
}

function checkAnswer() {
	var i, totalErrors=0;
	var answers = document.getElementsByTagName('input');
	for(i = 0; i < answers.length; i++){
    if(answers[i].value.toLowerCase() !== answers[i].getAttribute("data-answer").toLowerCase()) {
			answers[i].parentElement.className += ' error';
      totalErrors++
		} else {
			answers[i].parentElement.classList.remove("error");
		}
  }
  if (totalErrors == 0) { showAnswers(); alert('correct'); }
}

function showAnswers() {
	var i;
	var answers = document.getElementsByTagName('input');
	for(i = 0; i < answers.length; i++) {
    answers[i].value = answers[i].getAttribute("data-answer").toLowerCase();
    answers[i].parentElement.classList.remove("error");
  }
}

//crossword.js file

//NOTE: CrosswordUtils at bottom of page - I added new rownum colnum variable, values and html.push("<input type='text'... below for auto onfocus onkeyup advance to next input !
// Each cell on the crossword grid is null or one of these
function CrosswordCell(letter){
  this.char = letter; // the actual letter for the cell on the crossword
  // If a word hits this cell going in the "across" direction, this will be a CrosswordCellNode
  this.across = null; 
  // If a word hits this cell going in the "down" direction, this will be a CrosswordCellNode
  this.down = null;
}

// You can tell if the Node is the start of a word (which is needed if you want to number the cells)
// and what word and clue it corresponds to (using the index)
function CrosswordCellNode(is_start_of_word, index){
  this.is_start_of_word = is_start_of_word;
  this.index = index; // use to map this node to its word or clue
}

function WordElement(word, index){
  this.word = word; // the actual word
  this.index = index; // use to map this node to its word or clue
}

function Crossword(words_in, clues_in){
    var GRID_ROWS = 16;
    var GRID_COLS = 16;
    // This is an index of the positions of the char in the crossword (so we know where we can potentially place words)
    // example {"a" : [{'row' : 10, 'col' : 5}, {'row' : 62, 'col' :17}], {'row' : 54, 'col' : 12}], "b" : [{'row' : 3, 'col' : 13}]} 
    // where the two item arrays are the row and column of where the letter occurs
    var char_index = {};	

    // these words are the words that can't be placed on the crossword
    var bad_words;

    // returns the crossword grid that has the ratio closest to 1 or null if it can't build one
    this.getSquareGrid = function(max_tries){
        var best_grid = null;
        var best_ratio = 0;
        for(var i = 0; i < max_tries; i++){
            var a_grid = this.getGrid(1);
            if(a_grid == null) continue;
            var ratio = Math.min(a_grid.length, a_grid[0].length) * 1.0 / Math.max(a_grid.length, a_grid[0].length);
            if(ratio > best_ratio){
                best_grid = a_grid;
                best_ratio = ratio;
            }

            if(best_ratio == 1) break;
        }
        return best_grid;
    }

    // returns an abitrary grid, or null if it can't build one
    this.getGrid = function(max_tries){
        for(var tries = 0; tries < max_tries; tries++){
            clear(); // always start with a fresh grid and char_index
            // place the first word in the middle of the grid
            var start_dir = randomDirection();
            var r = Math.floor(grid.length / 2);
            var c = Math.floor(grid[0].length / 2);
            var word_element = word_elements[0];
            if(start_dir == "across"){
                c -= Math.floor(word_element.word.length/2);
            } else {
                r -= Math.floor(word_element.word.length/2);
            }

            if(canPlaceWordAt(word_element.word, r, c, start_dir) !== false){
                placeWordAt(word_element.word, word_element.index, r, c, start_dir);
            } else {
                bad_words = [word_element];
                return null;
            }

            // start with a group containing all the words (except the first)
            // as we go, we try to place each word in the group onto the grid
            // if the word can't go on the grid, we add that word to the next group 
            var groups = [];
            groups.push(word_elements.slice(1));
            for(var g = 0; g < groups.length; g++){
                word_has_been_added_to_grid = false;
                // try to add all the words in this group to the grid
                for(var i = 0; i < groups[g].length; i++){
                    var word_element = groups[g][i]; 
                    var best_position = findPositionForWord(word_element.word);
                    if(!best_position){ 
                        // make the new group (if needed)
                        if(groups.length - 1 == g) groups.push([]);
                        // place the word in the next group
                        groups[g+1].push(word_element);
                    } else {
                        var r = best_position["row"], c = best_position["col"], dir = best_position['direction'];
                        placeWordAt(word_element.word, word_element.index, r, c, dir);
                        word_has_been_added_to_grid = true;						
                    }
                }
                // if we haven't made any progress, there is no point in going on to the next group
                if(!word_has_been_added_to_grid) break;
            }
            // no need to try again
            if(word_has_been_added_to_grid) return minimizeGrid();  
        }

        bad_words = groups[groups.length - 1];
        return null;
    }

    // returns the list of WordElements that can't fit on the crossword
    this.getBadWords = function(){
        return bad_words;
    }

    // get two arrays ("across" and "down") that contain objects describing the
    // topological position of the word (e.g. 1 is the first word starting from
    // the top left, going to the bottom right), the index of the word (in the
    // original input list), the clue, and the word itself
    this.getLegend = function(grid){
        var groups = {"across" : [], "down" : []};
        var position = 1;
        for(var r = 0; r < grid.length; r++){	
            for(var c = 0; c < grid[r].length; c++){
                var cell = grid[r][c];
                var increment_position = false;
                // check across and down
                for(var k in groups){
                    // does a word start here? (make sure the cell isn't null, first)
                    if(cell && cell[k] && cell[k]['is_start_of_word']){
                        var index = cell[k]['index'];
                        groups[k].push({"position" : position, "index" : index, "clue" : clues_in[index], "word" : words_in[index]});
                        increment_position = true;
                    }
                }

                if(increment_position) position++;
            }
        }
        return groups;
    }	

    // move the grid onto the smallest grid that will fit it
    var minimizeGrid = function(){
        // find bounds
        var r_min = GRID_ROWS-1, r_max = 0, c_min = GRID_COLS-1, c_max = 0;
        for(var r = 0; r < GRID_ROWS; r++){
            for(var c = 0; c < GRID_COLS; c++){
                var cell = grid[r][c];
                if(cell != null){
                    if(r < r_min) r_min = r;
                    if(r > r_max) r_max = r;
                    if(c < c_min) c_min = c;
                    if(c > c_max) c_max = c;
                }
            }
        }
        // initialize new grid
        var rows = r_max - r_min + 1; 
        var cols = c_max - c_min + 1; 
        var new_grid = new Array(rows);
        for(var r = 0; r < rows; r++){
            for(var c = 0; c < cols; c++){
                new_grid[r] = new Array(cols);
            }
        }

        // copy the grid onto the smaller grid
        for(var r = r_min, r2 = 0; r2 < rows; r++, r2++){
            for(var c = c_min, c2 = 0; c2 < cols; c++, c2++){
                new_grid[r2][c2] = grid[r][c];
            }
        }

        return new_grid;
    }

    // helper for placeWordAt();
    var addCellToGrid = function(word, index_of_word_in_input_list, index_of_char, r, c, direction){
        var char = word.charAt(index_of_char);
        if(grid[r][c] == null){
            grid[r][c] = new CrosswordCell(char);

            // init the char_index for that character if needed
            if(!char_index[char]) char_index[char] = [];

            // add to index
            char_index[char].push({"row" : r, "col" : c});
        }

        var is_start_of_word = index_of_char == 0;
        grid[r][c][direction] = new CrosswordCellNode(is_start_of_word, index_of_word_in_input_list);

    }	

    // place the word at the row and col indicated (the first char goes there)
    // the next chars go to the right (across) or below (down), depending on the direction
    var placeWordAt = function(word, index_of_word_in_input_list, row, col, direction){
        if(direction == "across"){
            for(var c = col, i = 0; c < col + word.length; c++, i++){
                addCellToGrid(word, index_of_word_in_input_list, i, row, c, direction);
            }
        } else if(direction == "down"){
            for(var r = row, i = 0; r < row + word.length; r++, i++){
                addCellToGrid(word, index_of_word_in_input_list, i, r, col, direction);
            }			
        } else {
            throw "Invalid Direction";	
        }
    }

    // you can only place a char where the space is blank, or when the same
    // character exists there already
    // returns false, if you can't place the char
    // 0 if you can place the char, but there is no intersection
    // 1 if you can place the char, and there is an intersection
    var canPlaceCharAt = function(char, row, col){
        // no intersection
        if(grid[row][col] == null) return 0;
        // intersection!
        if(grid[row][col]['char'] == char) return 1;

        return false;
    }

    // determines if you can place a word at the row, column in the direction
    var canPlaceWordAt = function(word, row, col, direction){
        // out of bounds
        if(row < 0 || row >= grid.length || col < 0 || col >= grid[row].length) return false;

        if(direction == "across"){
            // out of bounds (word too long)
            if(col + word.length > grid[row].length) return false;
            // can't have a word directly to the left
            if(col - 1 >= 0 && grid[row][col - 1] != null) return false;
            // can't have word directly to the right
            if(col + word.length < grid[row].length && grid[row][col+word.length] != null) return false;

            // check the row above to make sure there isn't another word
            // running parallel. It is ok if there is a character above, only if
            // the character below it intersects with the current word
            for(var r = row - 1, c = col, i = 0; r >= 0 && c < col + word.length; c++, i++){
                var is_empty = grid[r][c] == null;
                var is_intersection = grid[row][c] != null && grid[row][c]['char'] == word.charAt(i);
                var can_place_here = is_empty || is_intersection;
                if(!can_place_here) return false;
            }

            // same deal as above, we just search in the row below the word
            for(var r = row + 1, c = col, i = 0; r < grid.length && c < col + word.length; c++, i++){
                var is_empty = grid[r][c] == null;
                var is_intersection = grid[row][c] != null && grid[row][c]['char'] == word.charAt(i);
                var can_place_here = is_empty || is_intersection;
                if(!can_place_here) return false;
            }

            // check to make sure we aren't overlapping a char (that doesn't match)
            // and get the count of intersections
            var intersections = 0;
            for(var c = col, i = 0; c < col + word.length; c++, i++){
                var result = canPlaceCharAt(word.charAt(i), row, c);
                if(result === false) return false;
                intersections += result;
            }
        } else if(direction == "down"){
            // out of bounds
            if(row + word.length > grid.length) return false;
            // can't have a word directly above
            if(row - 1 >= 0 && grid[row - 1][col] != null) return false;
            // can't have a word directly below
            if(row + word.length < grid.length && grid[row+word.length][col] != null) return false;

            // check the column to the left to make sure there isn't another
            // word running parallel. It is ok if there is a character to the
            // left, only if the character to the right intersects with the
            // current word
            for(var c = col - 1, r = row, i = 0; c >= 0 && r < row + word.length; r++, i++){
                var is_empty = grid[r][c] == null;
                var is_intersection = grid[r][col] != null && grid[r][col]['char'] == word.charAt(i);
                var can_place_here = is_empty || is_intersection;
                if(!can_place_here) return false;
            }

            // same deal, but look at the column to the right
            for(var c = col + 1, r = row, i = 0; r < row + word.length && c < grid[r].length; r++, i++){
                var is_empty = grid[r][c] == null;
                var is_intersection = grid[r][col] != null && grid[r][col]['char'] == word.charAt(i);
                var can_place_here = is_empty || is_intersection;
                if(!can_place_here) return false;
            }

            // check to make sure we aren't overlapping a char (that doesn't match)
            // and get the count of intersections
            var intersections = 0;
            for(var r = row, i = 0; r < row + word.length; r++, i++){
                var result = canPlaceCharAt(word.charAt(i, 1), r, col);
                if(result === false) return false;
                intersections += result;
            }
        } else {
            throw "Invalid Direction";	
        }
        return intersections;
    }

    var randomDirection = function(){
        return Math.floor(Math.random()*2) ? "across" : "down";
        //return "across";
    }

    var findPositionForWord = function(word){
        // check the char_index for every letter, and see if we can put it there in a direction
        var bests = [];
        for(var i = 0; i < word.length; i++){
            var possible_locations_on_grid = char_index[word.charAt(i)];
            if(!possible_locations_on_grid) continue;
            for(var j = 0; j < possible_locations_on_grid.length; j++){
                var point = possible_locations_on_grid[j];
                var r = point['row'];
                var c = point['col'];
                // the c - i, and r - i here compensate for the offset of character in the word
                var intersections_across = canPlaceWordAt(word, r, c - i, "across");
                var intersections_down = canPlaceWordAt(word, r - i, c, "down");

                if(intersections_across !== false)
                    bests.push({"intersections" : intersections_across, "row" : r, "col" : c - i, "direction" : "across"});
                if(intersections_down !== false)
                    bests.push({"intersections" : intersections_down, "row" : r - i, "col" : c, "direction" : "down"});
            }
        }

        if(bests.length == 0) return false;

        // find a good random position
        var best = bests[Math.floor(Math.random()*bests.length)];

        return best;
    }

    var clear = function(){
        for(var r = 0; r < grid.length; r++){
            for(var c = 0; c < grid[r].length; c++){
                grid[r][c] = null;
            }
        }
        char_index = {};
    }

    // constructor
    if(words_in.length < 2) throw "A crossword must have at least 2 words";
    if(words_in.length != clues_in.length) throw "The number of words must equal the number of clues";	

    // build the grid;
    var grid = new Array(GRID_ROWS);
    for(var i = 0; i < GRID_ROWS; i++){
        grid[i] = new Array(GRID_COLS);	
    }

    // build the element list (need to keep track of indexes in the originial input arrays)
    var word_elements = [];	
    for(var i = 0; i < words_in.length; i++){
        word_elements.push(new WordElement(words_in[i], i));
    }

    // I got this sorting idea from http://stackoverflow.com/questions/943113/algorithm-to-generate-a-crossword/1021800#1021800
    // seems to work well
    word_elements.sort(function(a, b){ return b.word.length - a.word.length; });
}

//I added new rownum colnum variable, values and html.push("<input type='text'... below for auto onfocus onkeyup advance to next input !
var rownum = 0, colnum = 0;
var CrosswordUtils = {
    PATH_TO_PNGS_OF_NUMBERS : "numbers/",

toHtml : function(grid, show_answers){
    if(grid == null) return;
    var html = [];
    html.push("<table id='crossword1' class='crossword'>");
    var label = 1; // Commencer à 1 pour les numéros
    for(var r = 0; r < grid.length; r++){
        html.push("<tr>");
        colnum = 0;
        rownum = rownum;
        rownum++;
        for(var c = 0; c < grid[r].length; c++){
            var cell = grid[r][c];

            var answer = '';
            var is_start_of_word = false;
            if(cell == null){
                var char = "&nbsp;";
                var css_class = "no-border";
            } else {
                var char = cell['char'];
                answer = char;
                var css_class = "";
                is_start_of_word = (cell['across'] && cell['across']['is_start_of_word']) || (cell['down'] && cell['down']['is_start_of_word']);
            }

            html.push("<td class='" + css_class + "' style='position: relative;'>"); // Ajout d'un style relative pour le conteneur de la cellule

            // Ajouter le numéro si c'est le début d'un mot
            if(is_start_of_word) {
                html.push("<div class='number'>" + label + "</div>"); // Afficher le numéro
                label++; // Incrémenter le numéro pour le prochain mot
            }

            colnum = colnum;
            colnum++;

            if(cell != null){
                if(show_answers) {
                    html.push(char);
                } else {
                    html.push("<input type='text' data-row='" + rownum + "' data-col='" + colnum + "' maxlength='1' onfocus='cellFocus(this)' onkeyup='keyup(this,false)' data-answer='" + answer + "' />");
                }
            } else {
                html.push("&nbsp;");
            }

            html.push("</td>"); // Fermer la cellule
        }
        html.push("</tr>");
    }
    html.push("</table>");
    return html.join("\n");
}

}
</script>
{% endblock %}
